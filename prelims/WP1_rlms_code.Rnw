\documentclass[12pt,a4paper]{article}

\usepackage[labelfont=bf]{caption}
\usepackage[font=small,labelfont=bf]{subcaption}

\usepackage[backend=bibtex, sorting=none,  style=authoryear]{biblatex}
\bibliography{Returns_to_Education_in_Russia}

\usepackage{float}

\usepackage[T1]{fontenc}

\usepackage[sc]{mathpazo}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
\usepackage{breakurl}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Working Paper 1: Draft}
\author{Suhas D. Parandekar, Ekaterina Melianova, Art\"{e}m Volgin}
\maketitle

<<Packages, results=hide>>=
library(foreign)
library(plyr); library(dplyr)
library(gmodels)
library(lmtest)
library(sqldf)
library(XLConnectJars)
library(questionr)
library(labelled)
library(tidyr)
library(magrittr)
library(ggplot2)
library(data.table)
library(pbapply)
library(knitr)
library(pander)
library(gridExtra)
library(rio)
library(stargazer)
library(xtable)
@

<<Data preprocessing>>=

# Working directory
wd <- paste0(normalizePath(Sys.getenv("USERPROFILE"), winslash = "/"), "/Desktop")
setwd(wd)
# Connecting with SQLite
db <- dbConnect(SQLite(), dbname=paste0(wd, "/rlms.db"))
# Modified cbind
cbind.all <- function (...) {
  nm <- list(...)
  nm <- lapply(nm, as.matrix)
  n <- max(sapply(nm, nrow))
  do.call(cbind, lapply(nm, function(x) rbind(x, matrix(, n - 
                                                          nrow(x), ncol(x)))))
}
# A function for variable selection
selectFromSQL <- function(column_names=NULL, column_blocks=NULL,
                          wave_number=NULL, dbname = "rlms.db"){
  "
  1. column_names - select specific column/s
  
  2. column_blocks - select specific block/s of columns. Available blocks:
  Bank services
  Children
  Daily activities
  Education
  Elections
  Employment
  Employment/finance (retrospective)
  Family
  Finance
  For women only
  Health assessment
  Identification variables
  Inequity issues
  Insurance
  Interviewer's remarks
  IT skills
  Law
  Living conditions
  Maternal capital
  Medical care
  Migration
  Military service
  Nationality issues
  Other
  Pension
  Personality assessment
  Politics
  Religion
  Safety/crimes
  Shopping
  Socio-demographics
  Sorces of news
  State services
  Transition period
  Traveling
  Trust
  
  3. wave_number - select specific wave/s in RLMS
  
  4. db_name - name of database in SQLite, by default rlms.db
  
  "
  
  # Add blocks to columns
  if (is.null(column_blocks) == FALSE){
    # Load table with blocks
    blocks_df <- sqldf('SELECT * from rlms_blocks', dbname = dbname)
    # Get columns from the selected blocks
    columns_from_blocks <- c()
    for (block in column_blocks){
      columns_from_blocks <- c(columns_from_blocks, blocks_df[blocks_df$column_block == block,]$column_names)
    }
    column_names <- c(column_names, columns_from_blocks)
  }
  
  # Add ids to the columns
  column_names <- unique(c("ID_W", "IDIND", "REDID_I", "ID_I", "ID_H", column_names))
  # Condition on a wave number 
  if (is.null(wave_number) == FALSE){
    if(length(wave_number) == 1){
      wave_condition <- paste('WHERE ID_W =', wave_number)
    } else {
      wave_condition <- paste('WHERE', paste(paste0('ID_W=', wave_number), collapse=' or '))
    }
  } else {
    wave_condition <- ""
  }
  
  # In case if the number of columns is 63 or larger (a default limitation of SQLite)
  if (length(column_names) >= 63){
    # Create a list with column chunks
    column_splits <- split(column_names, ceiling(seq_along(column_names)/63))
    # Add the columns by parts
    result_df <- data.frame()
    for (column_split in column_splits){
      if ('ID_W' %in% column_split == FALSE){
        column_split <- c('ID_W', column_split)
      }
      
      command_line <- paste(c("SELECT", paste(column_split, collapse=', '),
                              "FROM", paste(column_split, collapse=' NATURAL JOIN '),
                              wave_condition), collapse = ' ')
      cat('--- SQL command:', command_line, sep="\n")
      temp_df <- data.frame(sqldf(command_line, dbname = dbname))
      result_df <- data.frame(cbind.all(result_df, temp_df))
    }
    # Remove duplicates of the ID_W column
    result_df <- result_df[, -grep("ID_W.", colnames(result_df))]
    
  } else {
    command_line <- paste(c("SELECT", paste(column_names, collapse=', '),
                            "FROM", paste(column_names, collapse=' NATURAL JOIN '),
                            wave_condition), collapse = ' ')
    cat('--- SQL command:', command_line, sep="\n")
    result_df <- sqldf(command_line, dbname = dbname)
  }
  
  return(result_df)
}

############################################################################################

# Selecting the variables of interest
df_ <- selectFromSQL(c("AGE", "J13_2", "J10", "J40", "EDUC", "J1",
                       "J5A", "J5B", "H7_2", "H5",
                       "J23", "I2", "I4", "YEAR", "J40", "J35_2Y", "J35_2M",
                       "total_exper", "exper_main_", "exper_add_",
                       "J5A_", "J5B_", "J35_2Y_", "J35_2M_"))

# Fixing system and user-defined missings in the RLMS database

# Defining functions for a proper treatment of missing values
SysMisFix <- function(df){
  "SysMisFix changes chategorical NA to missing values"
  temp <- df
  for (i in colnames(df)){
    temp[,i] <- mapvalues(df[,i], "NA", NA, warn_missing = F)
  }
  return(temp)
}
UserMisFix <- function(df, na_range = 99999997:99999999){
  "UserMisFix labels user-defined missings as missing value "
  for (i in colnames(df)){
    if (is.character(df[,i]) == T){
      na_values(df[,i]) <- as.character(na_range)
      }
    else if (is.factor(df[,i]) == T){
      na_values(df[,i]) <- NULL
      }
    else if (!i %in% c("ID_W", "IDIND","YEAR","REDID_I","ID_I","ID_H")){
      na_values(df[,i]) <- na_range
    }
  }
  return(df)
} 

df_ <- SysMisFix(df_) # determining system missings
df_ <- UserMisFix(df_) # labelling user-defined missings

# A function for calculating descriptive statistics: a slightly extended version of freq
Freq <- function(var){
  result <- freq(var, levels = "values", total = T)
  result <- rbind(result, 
                  UserNA = apply(result[as.character(99999997:99999999),],2,sum),
                  TotalNA = apply(result[c(99999997:99999999, "NA"),],2,sum, na.rm = T))
  return(result)
}

############################################################################################

# Filtering age
#Freq(df_$AGE)
df <- df_[df_$AGE >= 25 & df_$AGE < 65,]

# Filtering employed
df <- df[df$J1 >= 1 & df$J1 < 5,]
#Freq(df$J1)

# Education 

# 4 categories:
# 0 - lower than secondary
# 1 - secondary 
# 2 - specialized / vocational
# 3 - higher and above

# Freq(df$EDUC)
df$EDUC <- as.numeric(df$EDUC)
df$edu_4 <- car::recode(df$EDUC, "0:7=0; 8:9=1; 10:11=2; 12=1; 13=2;
                            14=1; 15:17=2; 18=2; 19:20=3; 21:23=3")
# Freq(df$edu_4)
df <- UserMisFix(df) # fixing missings after creating a new variable

# Filtering 3 education levels
df <- df[df$edu_4>0,]
# Freq(df$edu_4)

# Education as factor
df$edu_4 <- factor(df$edu_4, levels=c(1,2,3),
                              labels=c("Secondary",
                                       "Vocational",
                                       "Higher"))

# Wage

# Select max wage if there is an additional job
# Question J13_2 is missing in 1994, 1995, 1996 - for those years let us use
# J10 as an approximation (the amount of money earned within the previous 30 days)
df$wage <- ifelse(df$YEAR < 1998, as.numeric(apply(df[,c("J10", "J40")], 1,
                                                   max, na.rm=T)),
                  as.numeric(apply(df[,c("J13_2", "J40")], 1, max, na.rm=T)))

# There are a few of those whose additional wage is greater than the main one
length(df[which(df$J40 > df$J13_2), "IDIND"]) # for 1998 - 2018
length(df[which(df$J40 > df$J10), "IDIND"]) # for 1994 - 1996

df <- UserMisFix(df) # fixing missings after creating a new variable
# tail(Freq(df$wage), n = 7L) # ~ 20k NAs

# Socio-demographics

# non-Russian
# Freq(df$I4)
df$non_russ[df$I4 == 1] <- 0
df$non_russ[df$I4 > 1] <- 1
df$non_russ[is.na(df$I4)] <- 1
Freq(df$non_russ)

# Gender
# Freq(df$H5)
df$female[df$H5==2] <- 1
df$female[df$H5==1] <- 0
# Freq(df$female)

# Generating a final dataset for the analysis
names(df)[which(colnames(df) == "total_exper")] <- "exper"
@

<<Contd>>=
# Tagging instances (tag1) and unique respondents (tag2)

# If a month of the start of work is missing but a year is not, let us use 1 (January) as an approximation
df[is.na(df$J5B)&is.na(df$J5A)==F, "J5B"] <- 1 # for a main work
df[is.na(df$J35_2M)&is.na(df$J35_2Y)==F, "J35_2M"] <- 1 # for an additional work

df$tag1 <- ifelse(df$exper_main_ > df$exper_add_ & 
                    is.na(df$exper_main_) == F & 
                    is.na(df$exper_add_) == F &
                    df$J5A == df$J5A_ &
                    df$J5B == df$J5B_, 1, 
                  ifelse(df$exper_main_ < df$exper_add_ & 
                           is.na(df$exper_main_) == F & 
                           is.na(df$exper_add_) == F &
                           df$J35_2Y == df$J35_2Y_ & 
                           df$J35_2M == df$J35_2M_, 1, 
                         ifelse(is.na(df$exper_main_) & 
                                is.na(df$exper_add_) == F &
                                df$J35_2Y == df$J35_2Y_ & 
                                df$J35_2M == df$J35_2M_, 1,
                              ifelse(is.na(df$exper_add_) & 
                                     is.na(df$exper_main_) == F &
                                     df$J5A == df$J5A_ &
                                     df$J5B == df$J5B_, 1, 
                                   ifelse(is.na(df$exper_main_) == T 
                                              & is.na(df$exper_add_) == T, -1, 0)))))

table(df$tag1) # 51850 instances with inconsistencies, 77903 - without
# sum(table(df$tag1))

resp <- df %>%
  group_by(IDIND) %>%
  summarise(tag2 = ifelse(any(tag1 == 0), 0, 1))

table(resp$tag2) # 13670 respondents with inconsistencies, 12674 - without

#################################################################################

# Another method of calculating experience:
# experience as a time between graduation and a current work

# Working directory
wd <- paste0(normalizePath(Sys.getenv("USERPROFILE"), winslash = "/"), "/Desktop")
setwd(wd)

# Vars of interest
grad_dates <- c("J72_1E", "J72_1E2", "J72_1E3", "J72_1E4", "J72_1E5",
                "J72_2E", "J72_2E2",
                "J72_3E", "J72_3E2",
                "J72_4E", "J72_4E2",
                "J72_5E", "J72_5E2", "J72_5E3", "J72_5E4",
                "J72_6E", "J72_6E2")
df_2 <- selectFromSQL(c(grad_dates, 
                             "J71", "J72_1", "J72_2", "J72_3", "J72_4", "J72_5", "J72_6", "H6")) %>% 
                             select(-c("ID_H", "REDID_I", "ID_I"))
df_2 <- SysMisFix(df_2) # determining system missings
df_2 <- UserMisFix(df_2) # labelling user-defined missings

# Merging with our subsample
df_2 <- df %>%
  left_join(df_2, by = c("IDIND", "ID_W"))

# Format
df_2[, grad_dates] <- sapply(df_2[, grad_dates], as.numeric)

# Denoting user NA
for (i in grad_dates){
  df_2[,i] <- ifelse(df_2[,i] == 99999997|
                          df_2[,i] == 99999998|
                          df_2[,i] == 99999999, NA, df_2[,i])
}
# Selecting the FIRST graduation among several (e.g., a person has 2 degrees)
# BY levels of education
df_2$J72_1E_min <- apply(df_2[, c("J72_1E", "J72_1E2", 
                                            "J72_1E3", "J72_1E4",
                                            "J72_1E5")], 1, min, na.rm=T)

df_2$J72_2E_min <- apply(df_2[, c("J72_2E", "J72_2E2")], 1, min, na.rm=T)
df_2$J72_3E_min <- apply(df_2[, c("J72_3E", "J72_3E2")], 1, min, na.rm=T)
df_2$J72_4E_min <- apply(df_2[, c("J72_4E", "J72_4E2")], 1, min, na.rm=T)
df_2$J72_5E_min <- apply(df_2[, c("J72_5E", "J72_5E2",
                                            "J72_5E3", "J72_5E4")], 1, min, na.rm=T)
df_2$J72_6E_min <- apply(df_2[, c("J72_6E", "J72_6E2")], 1, min, na.rm=T)

# A vector with the names of the selected graduation years
grady_min <- c("J72_1E_min", "J72_2E_min", "J72_3E_min",
               "J72_4E_min", "J72_5E_min", "J72_6E_min")

# Replacing infinity which indicates the absence of a certain degree
for (i in grady_min){
  df_2[,i] <- ifelse(is.infinite(df_2[,i]), NA, df_2[,i])
}

# Graduation age for each education level
df_2$grad_age_1E <- df_2$J72_1E_min - df_2$H6
df_2$grad_age_2E <- df_2$J72_2E_min - df_2$H6
df_2$grad_age_3E <- df_2$J72_3E_min - df_2$H6
df_2$grad_age_4E <- df_2$J72_4E_min - df_2$H6
df_2$grad_age_5E <- df_2$J72_5E_min - df_2$H6
df_2$grad_age_6E <- df_2$J72_6E_min - df_2$H6

# A vector with the names of graduation ages
grad_ages <- c("grad_age_1E", "grad_age_2E", "grad_age_3E",
               "grad_age_4E", "grad_age_5E", "grad_age_6E")

# Limiting the age of getting education by 25 years
# This is necessary due to people recieving additional
# degrees across their life-course: we are most interested
# in the highest level recieved within this interval
for (i in grad_ages){
  df_2[,i] <- ifelse(df_2[,i] > 25, NA, df_2[,i])
}
# summary(df_2[, grad_ages])

# Defining this age for those with any level after secondary
df_2$grad_age <- apply(df_2[,grad_ages], 1, max, na.rm=T)
# Defining this age for those with only secondary level
df_2$grad_age <- ifelse(is.na(df_2$J72_1E_min)&
                          is.na(df_2$J72_2E_min)&
                          is.na(df_2$J72_3E_min)&
                          is.na(df_2$J72_4E_min)&
                          is.na(df_2$J72_5E_min)&
                          is.na(df_2$J72_6E_min), 17, df_2$grad_age)
# Approximating this age for those who recieved their degree after 25 year
df_2$grad_age <- ifelse(is.infinite(df_2$grad_age), 20, df_2$grad_age)
# summary(df_2$grad_age)
# Freq(df_2$grady)

# Final graduation year
df_2$grady <- df_2$H6 + df_2$grad_age
# Final experience based on the time period after graduation
df_2$exper2 <- df_2$YEAR - df_2$grady
# summary(df_2$exper2

#################################################################################

# Note: df_ini is a df from mincer2a.R file with the initial experience
# variable (without inconsistency fixing)
setwd("C:/Country/Russia/Data/SEABYTE/RLMS/edreru/prelims")
df_ini <- readRDS("df_ini.rds")

# A table with instancies

# Merging experience computed on the basis of the initial variables and 
# experience as a time between graduation and a current work
df_t <- df %>%
  left_join(df_ini[, c("IDIND", "ID_W", "exper_ini")], by = c("IDIND", "ID_W")) %>%
  left_join(df_2[, c("IDIND", "ID_W", "exper2")], by = c("IDIND", "ID_W"))
df_t <- df_t[-which(is.na(df_t$exper)),]

# Formatting
df_t$exper <- as.numeric(df_t$exper)
df_t$exper_ini <- as.numeric(df_t$exper_ini)

# rlms_tbl0: means are aggregated by unique IDIND
rlms_tbl0 <- df_t  %>%
  group_by(IDIND) %>%
  summarise(N = n(),
            exp_mean_ = mean(exper, na.rm = T),
            exp_mean_ini_ = mean(exper_ini, na.rm = T),
            exp_mean_2_ = mean(exper2, na.rm = T)) 

# rlms_tbl: means are aggregated by the number of instances
rlms_tbl <- rlms_tbl0 %>%
  group_by(N) %>%
  summarise(N_resp = n(),
            exp_mean = mean(exp_mean_, na.rm = T),
            exp_mean_ini = mean(exp_mean_ini_, na.rm = T),
            exp_mean_2 = mean(exp_mean_2_, na.rm = T))

# Checking the distribution  
rlms_tbl$mult <- rlms_tbl$N*rlms_tbl$N_resp  
sum(rlms_tbl$mult) # ok  

# A list to which a t-test will be applied
list_splt_by_N <- split(rlms_tbl0, f = rlms_tbl0$N)

# Conducting a t-test
# Comparing between our EXP and the INITIAL one
t.test.pval_1 <- c() 
for (i in 1:length(list_splt_by_N)){
  base <- list_splt_by_N[[i]][['exp_mean_']]
  against <- list_splt_by_N[[i]][['exp_mean_ini_']]
  test <- t.test(base, against)
  t.test.pval_1[i] <- round(test$p.value,3)
}  

# Comparing between our EXP and the one based on the difference
# between graduation and a current work
t.test.pval_2 <- c() 
for (i in 1:length(list_splt_by_N)){
  base <- list_splt_by_N[[i]][['exp_mean_']]
  against <- list_splt_by_N[[i]][['exp_mean_2']]
  test <- t.test(base, against)
  t.test.pval_2[i] <- round(test$p.value,3)
}

# cbind.data.frame(rlms_tbl$N, t.test.pval)
@

\section*{RLMS Results}

\subsection*{Data}

To estimate returns to education in Russia we employed the Russian Longitudinal Monitoring Survey (RLMS) - the longest panel survey of individuals and households in Eastern Europe and Asia (\cite{kozyreva_081._2015}) and the only representative Russian survey with a sizable panel component allowing for a dynamic analysis. The data are notable for their reliability, diversity, and applicability to a variety of research questions. The RLMS embraces information on people's income and expenditure structure, their material well-being, educational and occupational behavior, health state and nutrition, migration, etc. High standards of the survey content accepted worldwide enable to conduct a comprehensive cross-country comparison. RLMS sampling procedures have been thoroughly and extensively described elsewhere (\cite{kozyreva_081._2015}). The present research uses all 23 waves that are currently available (1994 - 2018). A sub-sample selected for the empirical investigation includes working individuals aged 25-64 who are out of school and have positive labor market experience and income.
\\

\subsection*{Methods}

Our empirical analysis pertains to the examination of a slightly modified basic specification of a mincer-type wage equation (\cite{mincer_082._1974}). We present results for the general working population of the Russian Federation aged 25-64 as well as by gender and nationality. The specification of focus is as follows:

$$Log(Wage) = b_0 + b_1\cdot Educ + b_2\cdot Exp + b_3\cdot Exp^2 + b_4\cdot Gender + b_5\cdot Nationality + \epsilon$$

where $Log(Wage)$ is a logarithm of wage, $Educ$ stands for the highest attained level of education, $Exp$ and $Exp^2$ reflect the years of working experience and its quadratic term respectively, $Gender$ is a dummy variable for gender, $Nationality$ represents a person's nationality, $b_0$ is an intercept, $b_1 ... b_n$ are the respective slope estimates, $\epsilon$ refers to a normally distributed error term.
\\

\subsection*{Measures}

\subsubsection*{Dependent variable}

For the dependent variable we used the logarithm of an average monthly wage within the past year on a person's primary job (J13.2 variable in the RLMS dataset). If a person had an additional job, the maximum wage value among the two (J13.2 and J40) was selected for the analysis. In the waves from 1994 to 1996 the above mentioned question was absent; for those waves we exploited a variable about the average amount of money earned by a respondent within the past 30 days (J10) as a reasonable approximation.
\\

\subsubsection*{Independent variables}

We distinguished 3 categories for the {\bf education} variable (EDUC): (1) secondary, (2) vocational, and (3) higher. Incomplete levels were incorporated into the respective upper categories (e.g., incomplete higher - into higher). We are interested in exploring returns to vocational and higher education. Estimations of premiums to primary and secondary schooling levels are technically unreachable to us since the amounts of adults without primary education and with only primary level are minuscule in the general population. We also refused from a strategy of measuring education metrically in years due to a tangible variability of returns at each year of education: extrapolating yearly effects to any time period of schooling might be crude and erroneous.
\\

To create a variable displaying a person's {\bf experience} we leveraged four questions on a year and a month of both primary and additional job start (J5A, J5B, J35.2Y, and J25.2M). Based on these variables and the information on an interview date, we generated a labor market experience variable for each unique respondent in the sample by summing his or her experience time registered across RLMS waves. If an employed individual had missing values on a date of his or her start of work, we imputed those missings by the first non-missing record from previous waves. If only month of a job start lacked a valid response, we roughly assumed a respondent had started his or her work in January. In cases of the absence of a valid answer with regard to those questions in both primary and additional job in all RLMS waves a person have been surveyed, such cases (< 1\%) were dropped from the analysis. List-wise deletion strategy was also applied to the observations with "negative" experience (< 1\%) when according to one's responses a job started allegedly "after" the interview occurred.
\\

In addition, we elaborated a routine for detecting and fixing inconsistent responses to the questions about experience. Such pitfalls, impeding the correct computation of the experience variable, originate from the following two circumstances:

\begin{enumerate}
\item individuals, "covering" a job starting date throughout one or several successive waves and "disclosing" it later (e.g., a respondent in 2005 mentioned he or she had started to work in 2000, however, in 2001 a different response was recorded); 

\item individuals, naming an earlier job starting date compared to the mentioned preceding dates (e.g., a respondent in 2005 said he had started to work in 2000, but in 2001 he or she replied 1995 had been in fact the beginning year of his or her working activity). 
\end{enumerate}

In both situations the priority was given to earlier responses since the closeness to the actual job starting date can potentially downgrade the probability of making a mistake by a person. Incoherence correction involved 52\% of unique respondents or 40\% of instances in the pooled RLMS database (1994 - 2018). However, it should be noted that such an approach to the labor market experience measurement is not devoid of shortcomings. Tracking people's experience based solely on information present in the dataset implies we restrict people's career paths to what has been captured exclusively by the survey. Hence we assume everyone reports on their first job start when they are interviewed for the first time, which is not always the case. Therefore, we cannot be sure on the preciseness of calculations concerning experience variable for individuals surveyed little amount of times, albeit are certain about the experience data for people, participated in the survey many times. As a counter-argument we can contend that such systematic underestimation affects everyone equally, hence leaving a relative aspect intact.
\\

There is another method of computing a person's labor market experience frequent in past research. This method equates one's experience with a time distance between his or her graduation from the last institution and a current work. Such an approach has some disadvantages as well. First, it ignores the existence of unemployment which is of particular point of concern for people lacking higher education; that is why the method disproportionately overestimates people's labor market activity. Second, it does not account for the fact that people can continuously receive their education across their life-course, thus the method neglects a qualification upsurge in older ages. Third, the approach erases the variability in experience between people of the same age.
\\

Table 1 shows the results of averaging all the three ways of generating labor market experience by "cohorts" - groups of respondents aggregated on the basis of incidence number in the RLMS survey - and comparing the obtained means by a t-test. This table demonstrates that the two corresponding versions of experience computed with (EXP 1) and without (EXP 2) inconsistency correction gradually increase with the rise of the instance number, which is expected. Moreover, they are rather close in absolute values, nevertheless, entail a statistical difference (for the bulk of the cohorts t-test p-values are lower than 0.05). Therefore, perhaps, these variables cannot be leveraged interchangeably without introducing bias into the analysis. Importantly, both EXP 1 and EXP 2 take into consideration the fact that people can change their job, thus previous working experience is added to a current value. Besides, the table poses evidence that experience based on a graduation year (EXP 3) overestimates one's labor market activity since is greater than the corrected EXP 1 even for the most frequent RLMS participants (p-values of the respective t-tests are lower than 0.05). Overall, this indicates the necessity of harmonizing the data in the described manner. 
\\

<<Tagging>>=
# The resulting table
rlms_tbl_res <- cbind.data.frame(rlms_tbl, t.test.pval_1, t.test.pval_2)

# Naming
colnames(rlms_tbl_res) <- c("Cohort", "N resp", "EXP 1",
                            "EXP 2", "EXP 3", "N inst",
                            "t-tests 1: pv", "t-tests 2: pv")
# Rounding
rlms_tbl_res[, c("EXP 1", "EXP 2", "EXP 3")] <-
  round(rlms_tbl_res[, c("EXP 1", "EXP 2", "EXP 3")], 2)

@

\begin{table}[H]
        \centering
        \caption{Comparison between Initial and Corrected Versions of the Experience Variable}
        \label{tab:1}
<<Table with cohorts, results = tex>>=
print(xtable(rlms_tbl_res),
  floating=FALSE,
  include.rownames=F)
@
\end{table}


Finally, two socio-demographic variables were incorporated into the analysis, namely gender and nationality. We introduced gender in the form of a dummy variable with "1" standing for females, "0" - for males. Likewise, nationality reflected if a person did not identify him/herself as Russian.

\subsection*{Findings}

Figure 1 displays rates of returns to higher and vocational education in Russia in 1994-2018. The results suggest that on average wage premiums to university schooling in Russia are roughly 3-5 times greater than to vocational schooling depending on the year under focus. Overall, there is a moderate curved growth in both return types, achieving their peak in the early 2000s (83\% for higher education and 26\% for vocational education compared to the average earnings of workers with the secondary level), which is followed by a downward pattern (see Figure 1). This goes in line with the previous meta-analytic research (Lukyanova 2010).
\\

<<Regression results>>=

df_mincer <- df[, c("IDIND", "YEAR", "edu_4", "wage", "exper", "non_russ", "female")]
df_mincer$exper <- as.numeric(df_mincer$exper)
# summary(df_mincer)
# df[which(df$wage == 0), "ID_I"]

# Filtering the missings left
df_mincer <- df_mincer %>%
  filter(!is.na(wage) & !is.na(exper) & wage > 0)

# Empty list where the regression output will be written
lm_mincer_all <- vector("list", length(unique(df_mincer$YEAR)))
lm_mincer_f = lm_mincer_m = lm_mincer_rus = lm_mincer_nrus = lm_mincer_all 

vec_year <- unique(df_mincer$YEAR)

# Looping over each year
# all
for(i in seq(length(vec_year))){
  lm_mincer_all[[i]] <- lm(log(wage) ~ edu_4 + exper + I(exper^2) + non_russ + female,
                     data = df_mincer[df_mincer$YEAR == vec_year[i],])
}
names(lm_mincer_all) <- vec_year

# by gender
for(i in seq(length(vec_year))){
   lm_mincer_f[[i]] <- lm(log(wage) ~ edu_4 + exper + I(exper^2) + non_russ,
                       data = df_mincer[df_mincer$YEAR == vec_year[i] & 
                                          df_mincer$female == 1,])
   lm_mincer_m[[i]] <- lm(log(wage) ~ edu_4 + exper + I(exper^2) + non_russ,
                               data = df_mincer[df_mincer$YEAR == vec_year[i] & 
                                                  df_mincer$female == 0,])  
}

# by nationality
for(i in seq(length(vec_year))){
  lm_mincer_rus[[i]] <- lm(log(wage) ~ edu_4 + exper + I(exper^2) + female,
                         data = df_mincer[df_mincer$YEAR == vec_year[i] & 
                                            df_mincer$non_russ == 0,])
  lm_mincer_nrus[[i]] <- lm(log(wage) ~ edu_4 + exper + I(exper^2) + female,
                         data = df_mincer[df_mincer$YEAR == vec_year[i] & 
                                            df_mincer$non_russ == 1,])  
}

names(lm_mincer_f) <- vec_year
names(lm_mincer_m) <- vec_year

names(lm_mincer_rus) <- vec_year
names(lm_mincer_nrus) <- vec_year

# Summary if needed
smry_all <- lapply(lm_mincer_all, summary)
smry_f <- lapply(lm_mincer_f, summary)
smry_m <- lapply(lm_mincer_m, summary)
smry_rus <- lapply(lm_mincer_rus, summary)
smry_nrus <- lapply(lm_mincer_nrus, summary)

# Calculating returns by year for higher and vocational education

RoREs <- as.data.frame((matrix(ncol = 21, nrow = length(vec_year))))
colnames(RoREs) <-  c("YEAR", "returns_to_HE_all", "p_for_HE_all", "returns_to_VE_all", "p_for_VE_all",
                      "returns_to_HE_f", "p_for_HE_f", "returns_to_VE_f", "p_for_VE_f",
                      "returns_to_HE_m", "p_for_HE_m", "returns_to_VE_m", "p_for_VE_m",
                      "returns_to_HE_rus", "p_for_HE_rus", "returns_to_VE_rus", "p_for_VE_rus",
                      "returns_to_HE_nrus", "p_for_HE_nrus", "returns_to_VE_nrus", "p_for_VE_nrus")

# A function for percentages
percent <- function(x, digits = 1, format = "f", ...) {
  paste0(formatC(100 * x, format = format, digits = digits, ...), "%")
}

# Obtaining the values
for (i in seq(length(vec_year))){
  RoREs[i,] <- c(vec_year[i], (percent(exp(smry_all[[i]]$coefficients[3,1]) - 1)),
                 formatC(smry_all[[i]]$coefficients[3,4], digits = 2),
                 (percent(exp(smry_all[[i]]$coefficients[2,1]) - 1)),
                 formatC(smry_all[[i]]$coefficients[2,4], digits = 2),
                 
                 (percent(exp(smry_f[[i]]$coefficients[3,1]) - 1)),
                 formatC(smry_f[[i]]$coefficients[3,4], digits = 2),
                 (percent(exp(smry_f[[i]]$coefficients[2,1]) - 1)),
                 formatC(smry_f[[i]]$coefficients[2,4], digits = 2),
                 
                 (percent(exp(smry_m[[i]]$coefficients[3,1]) - 1)),
                 formatC(smry_m[[i]]$coefficients[3,4], digits = 2),
                 (percent(exp(smry_m[[i]]$coefficients[2,1]) - 1)),
                 formatC(smry_m[[i]]$coefficients[2,4], digits = 2),
                 
                 (percent(exp(smry_rus[[i]]$coefficients[3,1]) - 1)),
                 formatC(smry_rus[[i]]$coefficients[3,4], digits = 2),
                 (percent(exp(smry_rus[[i]]$coefficients[2,1]) - 1)),
                 formatC(smry_rus[[i]]$coefficients[2,4], digits = 2),
                 
                 (percent(exp(smry_nrus[[i]]$coefficients[3,1]) - 1)),
                 formatC(smry_nrus[[i]]$coefficients[3,4], digits = 2),
                 (percent(exp(smry_nrus[[i]]$coefficients[2,1]) - 1)),
                 formatC(smry_nrus[[i]]$coefficients[2,4], digits = 2))
}
@

<<Fig1>>=
x_axis <- c(c(1994, 1996), seq(2000, 2018, 2))
# Converting to data.table and melting in order to visualize
RoREs <- as.data.table(RoREs)
RoREs_1 <- melt(RoREs, measure=c("returns_to_HE_all", "returns_to_VE_all"))
RoREs_1$value <- as.numeric(substr(RoREs_1$value, 1, nchar(RoREs_1$value)-1))

# Plotting all
p1 <- ggplot(RoREs_1, aes(YEAR, value, group = variable, color = variable)) +
  geom_point(size = 3) +
  geom_smooth(se = F) +
  scale_y_continuous(limits = c(-10, 110), breaks = seq(-50, 110, 10)) +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1, size = 16),
        axis.text.y = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.key = element_rect(size = 16)) +
  labs(color = "Education level") +
  scale_color_manual(labels = c("Higher education", "Vocational education"),
                     values = c("darkgreen", "red")) +
  scale_x_discrete(breaks = x_axis) +
  ylab("Rate of returns, %") +
  xlab("Year")

# Saving
ggsave("p1.png")
@

\begin{figure}[H]
\begin{center}
  \centering
  \includegraphics[width=300pt]{p1.png}
  \caption{Rates of Returns to Higher and Vocational Education in Russia, RLMS 1994-2018}\label{fig:1}
\end{center}
\end{figure}

Notably, gender-based trends in Russia have a different shape across time with regard to schooling premiums. Particularly, males' payoffs to higher education (varying from 45\% to 76\%) turn out to be on a slightly decreasing slope, whereas women' returns are described by an inversely U-shaped pattern, reaching their maximum of 104\% in 2001. Within the last roughly 5 years wage premiums to higher education for women have stabilized around the level of men (~50\%). A similar comparative picture is observed with respect to vocational education, however, the described regularities are way less pronounced (see Figure 2): returns for males are almost flat within the time period under focus and the parabolic association for females is tangibly less concave. The overall outcome concerning payoffs to schooling isolated by gender has been confirmed in a similar fashion by past studies (e.g., Cheidvasser and Benítez-Silva 2007; Lukyanova 2010).

<<Fig2>>=
x_axis <- c(c(1994, 1996), seq(2000, 2018, 2))
# The same procedure for females
RoREs_2a <- melt(RoREs, measure=c("returns_to_HE_f", "returns_to_VE_f"))
RoREs_2a$value <- as.numeric(substr(RoREs_2a$value, 1, nchar(RoREs_2a$value)-1))

# Plotting females
p2a <- ggplot(RoREs_2a, aes(YEAR, value, group = variable, color = variable)) +
  geom_smooth(se = F) +
  geom_point(size = 3) +
  scale_y_continuous(limits = c(-10, 110), breaks = seq(-50, 110, 10)) +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1, size = 16),
        axis.text.y = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.key = element_rect(size = 16)) +
  scale_color_manual(labels = c("Higher education", "Vocational education"),
                     values = c("darkgreen", "red")) +
  scale_x_discrete(breaks = x_axis) +
  ylab("Rate of returns, %") +
  xlab("Year")

# Saving
ggsave("p2a.png")

# The same procedure for males
RoREs_2b <- melt(RoREs, measure=c("returns_to_HE_m", "returns_to_VE_m"))
RoREs_2b$value <- as.numeric(substr(RoREs_2b$value, 1, nchar(RoREs_2b$value)-1))

# Plotting males
p2b <- ggplot(RoREs_2b, aes(YEAR, value, group = variable, color = variable)) +
  geom_smooth(se = F) + 
  geom_point(size = 3) +
  scale_y_continuous(limits = c(-10, 110), breaks = seq(-50, 110, 10)) +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1, size = 16),
        axis.text.y = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.key = element_rect(size = 16)) +
  scale_color_manual(labels = c("Higher education", "Vocational education"),
                     values = c("darkgreen", "red")) +
  scale_x_discrete(breaks = x_axis) +
  ylab("Rate of returns, %") +
  xlab("Year")

# Saving
ggsave("p2b.png")
@

\newpage

\begin{figure}[H]
  \begin{minipage}[b]{.5\linewidth}
     \centering
     \hspace*{-0.7in}
     \includegraphics[width=270pt]{p2a.png}
     % plot 1
     \subcaption{Females}\label{fig:2a}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{.5\linewidth}
     \centering
     \hspace*{0in}
     \includegraphics[width=270pt]{p2b.png}
     % plot 2
     \subcaption{Males}\label{fig:2b}
  \end{minipage}
  \caption{Rates of Returns to Higher and Vocational Education in Russia, RLMS 1994-2018}\label{fig:2}
\end{figure}

For Russians payoffs to higher and vocational education are characterized by a pattern almost identical to the one uncovered for the whole population. As for non-Russians, the estimates of wage advantages regarding people with university education level compared to those with only secondary level are not statistically significant in the majority of time periods investigated (except for 2002-2006 and 2008). Nevertheless, the payoffs to vocational education for those who identified themselves as non-Russians are significant and the respective time trend is loosely distinguishable from the one registered for Russians. In other words, nationality seem to affect returns to higher education, but does not play a similar part with respect to vocational education.

<<Fig3>>=
# The same procedure for Russians
RoREs_3a <- melt(RoREs, measure=c("returns_to_HE_rus", "returns_to_VE_rus"))
RoREs_3a$value <- as.numeric(substr(RoREs_3a$value, 1, nchar(RoREs_3a$value)-1))

# Plotting Russians
p3a <- ggplot(RoREs_3a, aes(YEAR, value, group = variable, color = variable)) +
  geom_smooth(se = F) + 
  geom_point(size = 3) +
  scale_y_continuous(limits = c(-10, 110), breaks = seq(-50, 110, 10)) +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1, size = 16),
        axis.text.y = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.key = element_rect(size = 16)) +
  scale_color_manual(labels = c("Higher education", "Vocational education"),
                     values = c("darkgreen", "red")) +
  scale_x_discrete(breaks = x_axis) +
  ylab("Rate of returns, %") +
  xlab("Year")

# Saving
ggsave("p3a.png")

# The same procedure for non-Russians
RoREs_3b <- melt(RoREs, measure=c("returns_to_HE_nrus", "returns_to_VE_nrus"))
RoREs_3b$value <- as.numeric(substr(RoREs_3b$value, 1, nchar(RoREs_3b$value)-1))

# Plotting non-Russians
p3b <- ggplot(RoREs_3b, aes(YEAR, value, group = variable, color = variable)) +
  geom_smooth(se = F) + 
  geom_point(size = 3) +
  scale_y_continuous(limits = c(-10, 110), breaks = seq(-50, 110, 10)) +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 30, hjust = 1, size = 16),
        axis.text.y = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.key = element_rect(size = 16)) +
  scale_color_manual(labels = c("Higher education", "Vocational education"), 
                     values = c("darkgreen", "red")) +
  scale_x_discrete(breaks = x_axis) +
  ylab("Rate of returns, %") +
  xlab("Year")

# Saving
ggsave("p3b.png")
@

\begin{figure}[H]
  \begin{minipage}[b]{.5\linewidth}
     \centering
     \hspace*{-0.7in}
     \includegraphics[width=270pt]{p3a.png}
     % plot 1
     \subcaption{Russians}\label{fig:3a}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{.5\linewidth}
     \centering
     \hspace*{0in}
     \includegraphics[width=270pt]{p3b.png}
     % plot 2
     \subcaption{Non-Russians}\label{fig:3b}
  \end{minipage}
  \caption{Rates of Returns to Higher and Vocational Education in Russia, RLMS 1994-2018}\label{fig:4}
\end{figure}

\printbibliography  

\newpage
\section*{Appendix}

<<Regression tables, results=tex>>=
for (i in 1:length(vec_year)){
  stargazer(lm_mincer_all[i],
            lm_mincer_m[i],
            lm_mincer_f[i],
            lm_mincer_rus[i],
            lm_mincer_nrus[i],
            type = "latex",
            column.labels = c("Total Sample",
                              "Males", 
                              "Females", 
                              "Russians",
                              "Non-Russians"),
            covariate.labels = c("Vocational education",
                                 "Higher education",
                                 "Experience",
                                 "Experience squared",
                                 "Non-Russian",
                                 "Female"),
            title = paste0("Results of Mincer Analysis, RLMS ",
                         as.character(vec_year[i])),
            dep.var.caption = "",
            dep.var.labels.include = F,
            df = F)
  cat("\n\\newpage\n")
}
@


\end{document}